---
title: "Termite Microbiota Analysis in R - qiime2 output"
author: "Rajani"
date: "April 28, 2020"
output:
  html_document: 
    toc: true
    toc_float: true
  pdf_document: default
editor_options: 
  chunk_output_type: console
always_allow_html: yes
---



So where `setwd("C:/Users/Rajani/Desktop/Qiime_output/Files for R from qiime2")` is in the code below, you need to enter the path to where you saved the tutorial or your data.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

knitr::opts_knit$set(root.dir = ("C:/Users/Rajani/Desktop/Qiime_output/Files for R from qiime2"))
```



```{r}
#GREY box
```

#Introduction
Written for R v3.3.2 in RStudio v1.0.136

```{r}
source("https://bioconductor.org/biocLite.R")
biocLite("phyloseq")
if (!requireNamespace("BiocManager", quietly = TRUE))
   install.packages("BiocManager")
BiocManager::install(version = "3.10")
if (!requireNamespace("BiocManager", quietly = TRUE))
  install.packages("BiocManager")

```

library (BiocManager)
library(phyloseq)


#Data manipulation
##Load Packages

library(naniar)
library(zoo)

```{r Load packages, results="hide"}
#Analyses of Phylogenetics and Evolution package. Required for tree calculations to be used with phyloseq
#install.packages("ape")
#install.packages("phangorn")
#install.packages("VennDiagram")

library(ape)

#This package will also help us more easily manipulate our data
library(dplyr)

#Graphing package used in phyloseq. To edit the default setting of a plot, you need to use functions in this package.
library(ggplot2)

#This package is used to calculate and plot Venn diagrams as well as heatmaps
library(gplots)

#Linear mixed-effects models like repeated measures analysis
library(lme4)

#used to read in mothur-formatted files
library(phangorn)

#The phyloseq package seeks to address issues with multiple microbiome analysis packages by providing a set of functions that internally manage the organizing, linking, storing, and analyzing of phylogenetic sequencing data. In general, this package is used for UniFrac analyses.
library(phyloseq)

#A package to create interactive web graphics of use in 3D plots
library(plotly)

#This package will help us more easily manipulate our data, which are matrices
library(tidyr)

#The vegan package provides tools for descriptive community ecology. It has most basic functions of diversity analysis, community ordination and dissimilarity analysis. In general, this package is used for Bray-Curtis and Jaccard analyses.
library(vegan)

#Pretty Venn disgrams
library(VennDiagram)
```

##Load Data

```{r Load data}
#OTU table (shared file)
#The OTU table as exported from qiime has a pound sign before the header row. You need to delete that pound sign in a text editor.
OTU = read.table("transposed-rarified.txt", header=TRUE, sep="\t", stringsAsFactors = F)

#Taxonomy of each OTU
tax = read.table("taxonomy.tsv", header=TRUE, sep="\t")

#Metadata. Since we made this in Excel, not mothur, we can use the "row.names" modifier to automatically name the rows by the values in the first column (sample names)
meta = read.table("termite-meta.csv", header=TRUE, row.names=1, sep=",")

evenness = read.table("evenness.tsv", header=TRUE, row.names=1, sep="\t")

faith_pd = read.table("faith_pd.tsv", header=TRUE,row.names=1, sep="\t")

observed_otus = read.table("observed_otus.tsv", header=TRUE, row.names=1, sep="\t")

shannon = read.table("shannon.tsv", header=TRUE, row.names=1, sep="\t")
```


###OTU table

##The table was already transposed in the excel

```{r}
str(OTU)
row.names(OTU) = OTU[,1]
OTU.clean = OTU[,-1]
str(OTU.clean)
```


###Taxonomy table


```{r}
tax2 = separate(tax, Taxon, into = c("Domain", "Phylum", "Class", "Order", "Family", "Genus", "Species"), sep=";")
```



```{r}
#All the strings that need to be removed and replaced with NA
na_strings <- c(" s__", " g__", " f__", " o__", " c__")
#str(tax.clean)

tax3 = replace_with_na_all(tax2, condition = ~.x %in% na_strings)
```


```{r}
tax3[] <- t(apply(tax3, 1, zoo::na.locf))
tax3 = tax3[,-1]
tax3_mat <- as.matrix(tax3)

#Get the row names back

row.names(tax3_mat) <- tax2[,1]
tax.clean <- as.data.frame(tax3_mat)
#Would be good to check here to make sure the order of the two data frames was the same. You should do this on your own.
```

###Remove all the OTUs that don't occur in our OTU.clean data set
```{r}
tax.clean = tax.clean[row.names(tax.clean) %in% colnames(OTU.clean),]
```
```

###Metadata
These tables do not require any modification since I created them in Excel exactly as I need them for this R analysis. 

###Alpha Diversity tables
These tables will be merged for convenience and added to the metadata table as the original tutorial was organized.

```{r}
alpha_diversity = merge(faith_pd, evenness, by.x = 0, by.y = 0)
alpha_diversity = merge(alpha_diversity, observed_otus, by.x = "Row.names", by.y = 0)
alpha_diversity = merge(alpha_diversity, shannon, by.x = "Row.names", by.y = 0)

meta = merge(meta, alpha_diversity, by.x = 0, by.y = "Row.names")
row.names(meta) = meta$Row.names
meta = meta[,-1]
```



##Order the data

```{r Order the data}
OTU.clean = OTU.clean[order(row.names(OTU.clean)),]
meta = meta[order(row.names(meta)),]
```

Our taxonomy table is in the original order. Not sure if I need to change it yet.

##Set seed
We will be running some processes that rely on the random number generater. To make your analysis reproducible, we set the random seed.

```{r}
set.seed(8765)
```

#Alpha-diversity


```{r}
#Create 2x2 plot environment 
par(mfrow = c(2, 2))

#Plots
hist(meta$shannon, main="Shannon diversity", xlab="", breaks=10)
hist(meta$faith_pd, main="Faith phylogenetic diversity", xlab="", breaks=10)
hist(meta$pielou_e, main="Evenness", xlab="", breaks=15)
hist(meta$observed_otus, main="Observed OTUs", xlab="", breaks=15)
```



To test for normalcy statistically, we can run the Shapiro-Wilk test of normality.
```{r}
shapiro.test(meta$shannon)
shapiro.test(meta$pielou_e)
shapiro.test(meta$faith_pd)
shapiro.test(meta$observed_otus)
```




```{r}
#Run the ANOVA and save it as an object
aov.evenness.treatment = aov(pielou_e ~ treatment, data=meta)
#Call for the summary of that ANOVA, which will include P-values
summary(aov.evenness.treatment)
```


```{r}
TukeyHSD(aov.evenness.treatment)
```


```{r}

levels(meta$treatment)
#Re-order the groups because the default is 1yr-2w-8w
meta$treatment.ord = factor(meta$treatment, c("kan+meth", "kan", "meth", "biocontrol"))
levels(meta$treatment.ord)
#Return the plot area to 1x1
par(mfrow = c(1, 1))
#Plot
boxplot(pielou_e ~ treatment.ord, data=meta, ylab="Peilou evenness")

evenness <- ggplot(meta, aes(treatment.ord, pielou_e)) + 
  geom_boxplot(aes(color = treatment.ord)) + 
  ylim(c(0.5,1)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
ggsave("evenness.png", evenness, height = 3, width = 3)
```

```{r}
evenness_summary <- meta %>% # the names of the new data frame and the data frame to be summarised
  group_by(treatment.ord) %>%   # the grouping variable
  summarise(mean_evenness = mean(pielou_e),  # calculates the mean of each group
            sd_evenness = sd(pielou_e), # calculates the standard deviation of each group
            n_evenness = n(),  # calculates the sample size per group
            se_evenness = sd(pielou_e)/sqrt(n())) # calculates the standard error of each group
```

```{r}
evenness_se <- ggplot(evenness_summary, aes(treatment.ord, mean_evenness, fill = treatment.ord)) + 
  geom_col() + 
  geom_errorbar(aes(ymin = mean_evenness - se_evenness, ymax = mean_evenness + se_evenness), width=0.2) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +
  theme(legend.title = element_blank()) +
  labs(y="Pielou's evenness± SE", x = "") 

ggsave("evenness_se.png", evenness_se, height = 3, width = 3)

```


**Non-normally distributed metrics**


```{r}
kruskal.test(faith_pd ~ treatment.ord, data=meta)
kruskal.test(observed_otus ~ treatment.ord, data=meta)
```


```{r}
pairwise.wilcox.test(meta$faith_pd, meta$treatment.ord, p.adjust.method="BH")
pairwise.wilcox.test(meta$observed_otus, meta$treatment, p.adjust.method="BH")

```


```{r}
#Create 1x1 plot environment
par(mfrow = c(1, 3))
#Plot
boxplot(faith_pd ~ treatment.ord, data=meta, ylab="Faith phylogenetic diversity")
boxplot(pielou_e ~ treatment.ord, data=meta, ylab="Peilou evenness")
boxplot(observed_otus ~ treatment.ord, data=meta, ylab="species richness")


```


or with ggplot2

```{r}
faith_pd <- ggplot(meta, aes(treatment.ord, faith_pd)) + 
  geom_boxplot(aes(color = treatment.ord)) + 
  #ylim(c(0.5,1)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +
  theme(legend.title = element_blank()) +
  labs(y="Faith Phylogenetic Diversity", x = "treatment") 
#ggsave("pd.png", faith_pd, height = 3, width = 3)
```
For adding SE
```{r}
faith_pd_summary <- meta %>% # the names of the new data frame and the data frame to be summarised
  group_by(treatment.ord) %>%   # the grouping variable
  summarise(mean_pd = mean(faith_pd),  # calculates the mean of each group
            sd_pd = sd(faith_pd), # calculates the standard deviation of each group
            n_pd = n(),  # calculates the sample size per group
            se_pd = sd(faith_pd)/sqrt(n())) # calculates the standard error of each group
```



```{r}
faith_pd_se <- ggplot(faith_pd_summary, aes(treatment.ord, mean_pd, fill = treatment.ord)) + 
  geom_col() + 
  geom_errorbar(aes(ymin = mean_pd - se_pd, ymax = mean_pd + se_pd), width=0.2) + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +
  theme(legend.title = element_blank()) +
  labs(y="Faith phylogenetic diversity ± SE", x = "") 
#ggsave("pd-SE.png", faith_pd, height = 3, width = 3)
#ggsave("Phylogenetic diversity_se.png", evenness_se, height = 3, width = 3)

```

##Shannon 
kruskal.test(shannon ~ treatment.ord, data=meta)
pairwise.wilcox.test(meta$shannon, meta$treatment.ord, p.adjust.method="BH")

##plot both alpha diversity together
```{r}
#Create 1x1 plot environment
par(mfrow = c(2, 2))
#Plot
boxplot(faith_pd ~ treatment.ord, data=meta, ylab="Faith phylogenetic diversity")
boxplot(pielou_e ~ treatment.ord, data=meta, ylab="Peilou evenness")
boxplot(shannon ~ treatment.ord, data=meta, ylab="shannon")
boxplot(observed_otus ~ treatment.ord, data=meta, ylab="species richness")
##ggsave("pd.png", faith_pd)

```


**Normally distributed metrics**

My data is non-parametric



###Beta-diversity



```{r}
BC.nmds = metaMDS(OTU.clean, distance="bray", k=2, trymax=1000)
Jac.nmds = metaMDS(OTU.clean, distance="jaccard", k=2, trymax=1000)
```


```{r}
#if running line-by-line run this entire block at one time.
my_colors = c("blue", "green", "red", "black")
par(mfrow = c(1, 2))
#Create a blank plot for the nmds
plot(BC.nmds, type="n", main="Bray-Curtis") 
#Add the points colored by age
points(BC.nmds$points, display="treatment.ord", pch=20, col=my_colors[meta$treatment.ord])
#Add a legend
legend(-0.4, 1.1, legend=levels(meta$treatment.ord), col=my_colors, pch=20)

plot(BC.nmds, type="n", main="Jaccard") 
#Add the points colored by group
points(Jac.nmds$points, display="treatment.ord", pch=20, col=my_colors[meta$treatment.ord])
#Add a legend
legend(0.6, 1.1, legend=levels(meta$treatment.ord), col=my_colors, pch=20)

#ggsave("alpha-diversity.png", evenness, height = 5, width = 5)

```


```{r}
BC.nmds$stress

# a lower stress means the spatial distances in your NMDS more accurately represent your calculated similarites. <0.2 is basically required, <0.1 is better but uncommon. If its bad, maybe you need to recalculate the mds line above and use transformed data 
#autotransform = TRUE

# I like to merge my NMDS coordinates in together with my metadata to make one big dataframe, I think this makes plotting easier later on

nmds <-as.data.frame(BC.nmds$points)
metanmds <- merge(meta, nmds) #, by.x = 0, by.y = 0)
row.names(metanmds) <- metanmds[,1]
metanmds <- metanmds[,-1]
str(metanmds)
metanmds$treatment <- factor(metanmds$treatment)


# this generates a dataframe containing the group centroids

#The following line you may need to modify to indicate the column numbers that contain MDS1 and MDS2
NMDS.mean <- aggregate(metanmds, list(group=metanmds$treatment.ord), mean)
colnames(NMDS.mean) <- c('design', 'groupX', 'groupY')

# merging the group centroids with the rest of the NMDS data #
metanmds <- merge(metanmds, NMDS.mean, by.x = "treatment", by.y="design")

str(metanmds)

```



```{r}


ggplot(metanmds, aes(x=MDS1, y=MDS2)) +
  geom_point(aes(color=treatment.ord, shape= treatment)) +
  labs(x='NMDS 1', y= 'NMDS 2', caption = paste('Ordination stress: ', round(BC.nmds$stress, digits = 2))) +
  stat_ellipse(aes(color=treatment.ord), level = 0.95) +
  theme(legend.title = element_blank()) 

#ggsave("nmds_ellipses_all1.png", height = 3, width = 4)

```


```{r}
J.nmds = metaMDS(OTU.clean, distance="jaccard", k=2, trymax=1000)

#if running line-by-line run this entire block at one time.
plot(J.nmds, type="n", main="Jaccard")
points(Jac.nmds$points, display="treatment.ord", pch=20, col=my_colors[meta$treatment.ord])
legend(0.57, 0.3, legend=levels(meta$treatment.ord), col=my_colors, pch=20)
```

***Jaccard Like bray-curtis##3

```{r}
J.nmds$stress

# a lower stress means the spatial distances in your NMDS more accurately represent your calculated similarites. <0.2 is basically required, <0.1 is better but uncommon. If its bad, maybe you need to recalculate the mds line above and use transformed data 
#autotransform = TRUE

# I like to merge my NMDS coordinates in together with my metadata to make one big dataframe, I think this makes plotting easier later on

nmds <-as.data.frame(BC.nmds$points)
metanmds <- merge(meta, nmds) #by.x = 0, by.y = 0)
row.names(metanmds) <- metanmds[,1]
metanmds <- metanmds[,-1]
str(metanmds)
metanmds$treatment <- factor(metanmds$treatment)


# this generates a dataframe containing the group centroids

#The following line you may need to modify to indicate the column numbers that contain MDS1 and MDS2
NMDS.mean <- aggregate(metanmds,list(group=metanmds$treatment.ord), mean)
colnames(NMDS.mean) <- c('design', 'groupX', 'groupY')

# merging the group centroids with the rest of the NMDS data #
metanmds <- merge(metanmds, NMDS.mean, by.x = "treatment", by.y="design")

str(metanmds)




```

```{r}
ggplot(metanmds, aes(x=MDS1, y=MDS2)) +
  geom_point(aes(color=treatment.ord, shape=treatment)) +
  labs(x='NMDS 1', y= 'NMDS 2', caption = paste('Ordination stress: ', round(BC.nmds$stress, digits = 2))) +
  stat_ellipse(aes(color=treatment.ord), level = 0.95) +
  theme(legend.title = element_blank()) 

#ggsave("nmds_ellipses_all.png", height = 3, width = 4)
```


Install.packages ("qiime2R")


```{r}
if (!requireNamespace("devtools", quietly = TRUE)){install.packages("devtools")}
devtools::install_github("jbisanz/qiime2R") # current version is 0.99.20
install.packages("devtools")
```

library(qiime2R)
library (devtools)




```{r}
library(qiime2R)
metadata = read.table("termite-meta.csv", header=TRUE, sep=",")
#metadata <-read_q2metadata ("termite-metadata.tsv")
#metadata<-read_q2metadata("unused files in R/termite-metadata.tsv")
wunifrac <- read_qza ("weighted_unifrac_pcoa_results.qza")


wunifrac$data$Vectors %>%
  select(SampleID, PC1, PC2) %>%
  left_join(metadata) %>%
  #left_join(shannon) %>%
  ggplot(aes(x=PC1, y=PC2, color=`treatment`, shape=)) +
  geom_point(alpha=1) + #alpha controls transparency and helps when points are overlapping
  theme_q2r() +
  #scale_shape_manual(values=c(16,1), name="treatment") + #see http://www.sthda.com/sthda/RDoc/figure/graphs/r-plot-pch-symbols-points-in-r.png for numeric shape codes
  scale_size_continuous(name="Shannon Diversity") +
  scale_color_discrete(name="treatment")
  #ggsave("wUF-PCoA.pdf", height=3, width=3, device="pdf") # save a PDF 3 inches by 4 inches
  #ggsave("wUF-PCoA_bigger.pdf", height=3, width=4, device="pdf") # save a PDF 3 inches by 4 inches
```


```{r}
library(qiime2R)
metadata = read.table("termite-meta.csv", header=TRUE, sep=",")
#metadata <-read_q2metadata ("termite-metadata.tsv")
#metadata<-read_q2metadata("unused files in R/termite-metadata.tsv")
wunifrac <- read_qza ("weighted_unifrac_pcoa_results.qza")


wunifrac$data$Vectors %>%
  select(SampleID, PC1, PC3) %>%
  left_join(metadata) %>%
  #left_join(shannon) %>%
  ggplot(aes(x=PC3, y=PC1, color=`treatment`, shape=)) +
  geom_point(alpha=1) + #alpha controls transparency and helps when points are overlapping
  theme_q2r() +
  #scale_shape_manual(values=c(16,1), name="treatment") + #see http://www.sthda.com/sthda/RDoc/figure/graphs/r-plot-pch-symbols-points-in-r.png for numeric shape codes
  scale_size_continuous(name="Shannon Diversity") +
  scale_color_discrete(name="treatment")
  #ggsave("wUF-PCoA.pdf", height=4, width=5, device="pdf") # save a PDF 3 inches by 4 inches
  #ggsave("wUF-PCoA_bigger_1,3.pdf", height=3, width=4, device="pdf") # save a PDF 3 inches by 4 inches
```


```{r}
library(qiime2R)
metadata = read.table("termite-meta.csv", header=TRUE, sep=",")
#metadata <-read_q2metadata ("termite-metadata.tsv")
#metadata<-read_q2metadata("unused files in R/termite-metadata.tsv")
wunifrac <- read_qza ("weighted_unifrac_pcoa_results.qza")


wunifrac$data$Vectors %>%
  select(SampleID, PC2, PC3) %>%
  left_join(metadata) %>%
  #left_join(shannon) %>%
  ggplot(aes(x=PC3, y=PC2, color=`treatment`, shape=)) +
  geom_point(alpha=1) + #alpha controls transparency and helps when points are overlapping
  theme_q2r() +
  #scale_shape_manual(values=c(16,1), name="treatment") + #see http://www.sthda.com/sthda/RDoc/figure/graphs/r-plot-pch-symbols-points-in-r.png for numeric shape codes
  scale_size_continuous(name="Shannon Diversity") +
  scale_color_discrete(name="treatment")
  #ggsave("wUF-PCoA_2-3.pdf", height=4, width=5, device="pdf") # save a PDF 3 inches by 4 inches
  #ggsave("wUF-PCoA_bigger_2-3.pdf", height=3, width=4, device="pdf") # save a PDF 3 inches by 4 inches
```




####Creating a Phyloseq Object

```{r}
library(qiime2R)
physeq<-qza_to_phyloseq (
    features="table.qza",
    tree="rooted-tree.qza",
    "termite-taxonomy.qza",
    metadata = "termite.metadata.txt"
    )
```





For Bray-Curtis:

```{r}
#if running line-by-line run this entire block at one time.
plot(BC.nmds, type="n", main="Bray-Curtis")
points(BC.nmds, pch=20, display="sites", col=my_colors[meta$treatment.ord])
legend(1.2, 0, legend=levels(meta$treatment.ord), col=my_colors, pch=20)
#Add fitted variables
plot(fit.BC, col="black")
```

You could also ask it to only plot variables with a fit P-value < 0.05. So we would only see the centroids
```{r}
#if running line-by-line run this entire block at one time.
plot(BC.nmds, type="n", main="Bray-Curtis")
points(BC.nmds, pch=20, display="sites", col=my_colors[meta$treatment.ord])
legend(-6, 2, legend=levels(meta$treatment.ord), col=my_colors, pch=20)
#Add fitted variables
plot(fit.BC, col="black", p.max=0.05)
```




```{r}
fit.BC.OTU = envfit(BC.nmds, OTU.clean[,1:10])
fit.BC.OTU

#We will only plot significant arrows in this case
#if running line-by-line run this entire block at one time.
plot(BC.nmds, type="n", main="Bray-Curtis")
points(BC.nmds, pch=20, display="sites", col=my_colors[meta$treatment.ord])
legend(-6, 2, legend=levels(meta$treatment.ord), col=my_colors, pch=20)
#Add fitted variables
plot(fit.BC.OTU, col="black", p.max=0.05)
```


##Statistically test beta-diversity
While nMDS gives us a visual of beta-diversity, it does not test for statistical differences. We do this with permutational analysis of variance (PERMANOVA) or analysis of similarity (ANOSIM). These test whether the overall microbial community differs by your variable of interest.



###PERMANOVA
For Bray-Curtis or Jaccard, we use the `vegan` package to calculate distances and run PERMANOVA. As with ANOVA/glm of alpha-diversity, we want to include all variables that could interact in one model.


```{r}
#Calculate distance and save as a matrix
BC.dist=vegdist(OTU.clean, distance="bray")
#Run PERMANOVA on distances.
adonis(BC.dist ~ treatment, data = meta, permutations = 1000)
```


```{r}
#Calculate distance and save as a matrix
J.dist=vegdist(OTU.clean, distance="jaccard")
#Run PERMANOVA on distances.
adonis(J.dist ~ treatment.ord, data = meta, permutations = 1000)
```


For example, Bray-Curtis:
```{r}
anosim(BC.dist, meta$treatment, permutations = 1000)
```

```{r}
anosim(J.dist, meta$treatment, permutations = 1000)
```



#Other visualizations
##Bar charts


install.packages("ggplot2")
install.packages("reshape2")
library(ggplot2)
library(reshape2)
librarypackageVersion("phyloseq")
library("phyloseq")


```{r}
library(qiime2R)
physeq<-qza_to_phyloseq (
    features="table.qza",
    tree="rooted-tree.qza",
    "termite-taxonomy.qza",
    metadata = "termite.metadata.txt"
    )
```




```{r Bar_charts}
plot_bar(physeq, fill="Phylum")
```

```{r Bar_charts}
plot_bar(physeq, fill="Phylum")
```


We can simplify by grouping our samples by age group
```{r}
plot_bar(physeq, x="treatment", fill="Phylum") 
```

And removing the lines between OTUs in the bars
```{r}
plot_bar(physeq, x="treatment", fill="Phylum") + geom_bar(aes(color=Phylum, fill=Phylum), stat="identity", position="stack")
```

And only showing the top 15 most abundant phyla
```{r}
#Sort the Phyla by abundance and pick the top 15
top15P.names = sort(tapply(taxa_sums(physeq), tax_table(physeq)[, "Phylum"], sum), TRUE)[1:15]
#Cut down the physeq data to only the top 5 Phyla
top15P = subset_taxa(physeq, Phylum %in% names(top15P.names))
#Plot
plot_bar(top15P, x="treatment", fill="Phylum") + geom_bar(aes(color=Phylum, fill=Phylum), stat="identity", position="stack")

```


And only showing the top 10 most abundant phyla
```{r}
#Sort the Phyla by abundance and pick the top 5
top10P.names = sort(tapply(taxa_sums(physeq), tax_table(physeq)[, "Phylum"], sum), TRUE)[1:10]
#Cut down the physeq data to only the top 10 Phyla
top10P = subset_taxa(physeq, Phylum %in% names(top10P.names))
#Plot
plot_bar(top10P, x="treatment", fill="Phylum") + geom_bar(aes(color=Phylum, fill=Phylum), stat="identity", position="stack")
```


##Let's explore some of the bar chart options family level idendtification

```{r Bar_charts}
plot_bar(physeq, fill="Family")
```

```{r Bar_charts}
plot_bar(physeq, fill="Family")
```

We can simplify by grouping our samples by age group
```{r}
plot_bar(physeq, x="treatment", fill="Family") 
```

And removing the lines between OTUs in the bars
```{r}
plot_bar(physeq, x="treatment", fill="Family") + geom_bar(aes(color=Family, fill=Family), stat="identity", position="stack")
```

And only showing the top 20 most abundant family
```{r}
#Sort the Phyla by abundance and pick the top 15
top20P.names = sort(tapply(taxa_sums(physeq), tax_table(physeq)[, "Family"], sum), TRUE)[1:20]
#Cut down the physeq data to only the top 15 Phyla
top20P = subset_taxa(physeq, Family %in% names(top20P.names))
#Plot
plot_bar(top20P, x="treatment", fill="Family") + geom_bar(aes(color=Family, fill=Family), stat="identity", position="stack")
```




#Relative abundance in phyla level

```{r}
# Set colors for plotting
my_colors <- c(
  '#a6cee3','#1f78b4','#b2df8a','#33a02c','#fb9a99','#e31a1c',
  '#fdbf6f','#ff7f00','#cab2d6','#6a3d9a','#ffff99','#b15928', 
  "#CBD588", "#5F7FC7", "orange","#DA5724", "#508578", "#CD9BCD",
   "#AD6F3B", "#673770","#D14285", "#652926", "#C84248", 
  "#8569D5", "#5E738F","#D1A33D", "#8A7C64", "#599861", "black"
)

#If you want different taxonomic level, find and replace the taxonomic level listed here
my_level <- c("Phylum")
#rm(taxa.summary)

ml ="Phylum"
for(ml in my_level){
  print(ml)
  
  taxa.summary <- physeq %>%
    tax_glom(taxrank = ml) %>%                     # agglomerate at Family level
    transform_sample_counts(function(x) {x/sum(x)} ) %>% # Transform to rel. abundance
    psmelt()  %>%                                           # Melt to long format
    group_by(treatment, get(ml)) %>%
    summarise(Abundance.average=mean(Abundance)) 
  names(taxa.summary)[2] <- ml
  
  physeq.taxa.average <- taxa.summary %>% 
    group_by(get(ml)) %>%
    summarise(overall.average=mean(Abundance.average))
  names(physeq.taxa.average)[1] <- ml
  
  # merging the phyla means with the metadata #
  physeq_meta <- merge(taxa.summary, physeq.taxa.average)
    
  abund_filter <- 0.001
  physeq_meta_filtered <- filter(physeq_meta, overall.average>abund_filter)
  str(physeq_meta_filtered)
  
  physeq_meta_filtered$treatment = factor(physeq_meta_filtered$treatment, c("kan", "kan+meth", "meth", "biocontrol"))
  unique(physeq_meta_filtered$`get(ml)`)
  
  ##To remove extraction blank from relative abundance 
   physeq_meta_filtered2= subset(physeq_meta_filtered, treatment == "kan" |treatment == "kan+meth"|treatment == "meth"|treatment == "biocontrol") 
   
  
  # Plot 
  ggplot(physeq_meta_filtered2, aes(x = treatment, y = Abundance.average, fill = get(ml))) + 
    #facet_grid(.~subject) +
    geom_bar(stat = "identity") +
    scale_fill_manual(values = my_colors) +
    # Remove x axis title
    #theme(axis.title.x = element_blank()) + 
    ylim(c(0,1)) +
    guides(fill = guide_legend(reverse = F, keywidth = .5, keyheight = .5, ncol = 1)) +
    theme(legend.text=element_text(size=8)) +
    #theme(legend.position="bottom") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +
    ylab("Relative Abundance") +
    ggtitle(paste0(ml, " (>", abund_filter * 100,"%) Composition of microbiome samples")) 
ggsave(paste0("BarPlot_AllSamples_phylum.png"), height = 5, width= 5)
}
```



##Relative abundance in family level


```{r}
# Set colors for plotting
# Set colors for plotting
my_colors <- c(
  '#a6cee3','#1f78b4','#b2df8a','#33a02c','#fb9a99','#e31a1c',
  '#fdbf6f','#ff7f00','#cab2d6','#6a3d9a','#ffff99','#b15928', 
  "#CBD588", "#5F7FC7", "orange","#DA5724", "#508578", "#CD9BCD",
   "#AD6F3B", "#673770","#D14285", "#652926", "#C84248", 
  "#8569D5", "#5E738F","#D1A33D", "#8A7C64", "#599861", "black"
)

#If you want different taxonomic level, find and replace the taxonomic level listed here
my_level <- c("Family")


ml ="Family"
for(ml in my_level){
  print(ml)
  
  taxa.summary.fam <- physeq %>%
    tax_glom(taxrank = ml) %>%                     # agglomerate at Family level
    transform_sample_counts(function(x) {x/sum(x)} ) %>% # Transform to rel. abundance
    psmelt()  %>%                                           # Melt to long format
    group_by(treatment, get(ml)) %>%
    summarise(Abundance.average=mean(Abundance)) 
  names(taxa.summary.fam)[2] <- ml
  
  physeq.taxa.average.fam <- taxa.summary.fam %>% 
    group_by(get(ml)) %>%
    summarise(overall.average=mean(Abundance.average))
  names(physeq.taxa.average.fam)[1] <- ml
  
  # merging the phyla means with the metadata #
  physeq_meta.fam <- merge(taxa.summary.fam, physeq.taxa.average.fam)
    
  abund_filter <- 0.01
  physeq_meta_filtered.fam <- filter(physeq_meta.fam, overall.average>abund_filter)
  str(physeq_meta_filtered.fam)
  
   physeq_meta_filtered.fam$treatment = factor(physeq_meta_filtered.fam$treatment, c("kan", "kan+meth", "meth", "biocontrol", "NC"))
  unique(physeq_meta_filtered.fam$`get(ml)`)
  
   ##To remove extraction blank from relative abundance 
   physeq_meta_filtered2.fam= subset(physeq_meta_filtered.fam, treatment == "kan" |treatment == "kan+meth"|treatment == "meth"|treatment == "biocontrol") 
  
  # Plot 
  ggplot(physeq_meta_filtered2.fam, aes(x = treatment, y = Abundance.average, fill = get(ml))) + 
    #facet_grid(.~subject) +
    geom_bar(stat = "identity") +
    scale_fill_manual(values = my_colors) +
    # Remove x axis title
    #theme(axis.title.x = element_blank()) + 
    ylim(c(0,1)) +
    guides(fill = guide_legend(reverse = F, keywidth = .5, keyheight = .5, ncol = 1)) +
    theme(legend.text=element_text(size=8)) +
    #theme(legend.position="bottom") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +
    ylab("Relative Abundance") +
    ggtitle(paste0(ml, " (>", abund_filter * 100,"%) Composition of microbiome samples")) 
ggsave(paste0( "BarPlot_AllSamples.fam.png"), height = 5, width= 5)
}
```



#### above from here to other visualizations from another tutorial

###RANDOM FOREST analysis

from Michelle Berry
https://rpubs.com/michberr/randomforestmicrobe

library(ggplot2)
library(vegan)
library(dplyr)
library(magrittr)
library(scales)
library(grid)
library(reshape2)
library(phyloseq)
library(randomForest)
library(knitr)
library(stringr)

```{r}
#install.packages("randomForest")
library(randomForest)
#Check how many OTUs you have. If you have more than 1000, you may want to filter out rare OTUs, as shown below.

ntaxa(physeq)

# Set prunescale 
prunescale = 0.0001
seq_depth = sample_sums(physeq)[1]

# Prune out rare OTUs by mean relative abundance set by prunescale
tax.mean <- taxa_sums(physeq)/nsamples(physeq)

#Select the samples we want to compare
rf.samples = c("meth", "biocontrol")
physeq.prune <- prune_taxa(tax.mean > prunescale*seq_depth, physeq)
physeq.prune2 <- prune_samples(sample_data(physeq.prune)$treatment == rf.samples[1] | sample_data(physeq.prune)$treatment == rf.samples[2], physeq.prune)

physeq.prune2

# Make a dataframe of training data with OTUs as column and samples as rows
predictors <- t(otu_table(physeq.prune2))
dim(predictors)
```
We have 16 samples and 453 ASVs


```{r}
# Make one column for our outcome/response variable 
response <- as.factor(sample_data(physeq.prune2)$treatment)

# Combine them into 1 data frame
rf.data <- data.frame(response, predictors)

```


Results
```{r}
set.seed(2)

physeq.classify <- randomForest(response~., data = rf.data, ntree = 100)
print(physeq.classify)
```


```{r}
names(physeq.classify)
```

###plots

```{r}


imp <- importance(physeq.classify)
imp <- data.frame(predictors = rownames(imp), imp)

# Order the predictor levels by importance
imp.sort <- arrange(imp, desc(MeanDecreaseGini))
imp.sort$predictors <- factor(imp.sort$predictors, levels = imp.sort$predictors)

#We need some editing to remove leading "X" in front of ASV names that should start with a numeral.
imp.sort$predictors <- str_remove(imp.sort$predictors, "[X]")

# Select the top 20 predictors
imp.20 <- imp.sort[1:20, ]

imp.20$predictors <-  factor(imp.20$predictors, levels = imp.20$predictors)

# ggplot
ggplot(imp.20, aes(x = predictors, y = MeanDecreaseGini)) +
  geom_bar(stat = "identity", fill = "indianred") +
  coord_flip() +
  ggtitle(paste("Most important ASVs between", rf.samples[1], "and ", rf.samples[2]))


# What are those OTUs?
otunames <- imp.20$predictors
r <- rownames(tax_table(physeq)) %in% otunames
rf.imp.asv <- as.data.frame(tax_table(physeq)[r, ])
imp.20_tax <- merge(imp.20, rf.imp.asv, by.x = "predictors", by.y = 0)

# New ggplot
ggplot(imp.20_tax, aes(x = predictors, y = MeanDecreaseGini)) +
  geom_bar(stat = "identity", aes(fill = Family)) +
  scale_fill_manual(values = my_colors) +
  coord_flip() +
  ggtitle(paste("Most important ASVs between", rf.samples[1], "and", rf.samples[2]))
ggsave(paste0("RandomForest_", rf.samples[1], "_", rf.samples[2], "_names.png"), height = 4, width = 7)
write.table(imp.20_tax, "rf_top20_taxa.tsv", sep="\t", row.names=FALSE, quote = FALSE)
```

## To compare meth-kan+meth

```{r}
#install.packages("randomForest")
library(randomForest)
#Check how many OTUs you have. If you have more than 1000, you may want to filter out rare OTUs, as shown below.

ntaxa(physeq)

# Set prunescale 
prunescale = 0.0001
seq_depth = sample_sums(physeq)[1]

# Prune out rare OTUs by mean relative abundance set by prunescale
tax.mean <- taxa_sums(physeq)/nsamples(physeq)

#Select the samples we want to compare
rf.samples = c("meth", "kan+meth")
physeq.prune <- prune_taxa(tax.mean > prunescale*seq_depth, physeq)
physeq.prune2 <- prune_samples(sample_data(physeq.prune)$treatment == rf.samples[1] | sample_data(physeq.prune)$treatment == rf.samples[2], physeq.prune)

physeq.prune2

# Make a dataframe of training data with OTUs as column and samples as rows
predictors <- t(otu_table(physeq.prune2))
dim(predictors)

# Make one column for our outcome/response variable 
response <- as.factor(sample_data(physeq.prune2)$treatment)

# Combine them into 1 data frame
rf.data <- data.frame(response, predictors)

#Results
set.seed(2)

physeq.classify <- randomForest(response~., data = rf.data, ntree = 100)
print(physeq.classify)
#In most statistical learning algorithms, the data needs to be split up into “training” and “test” data. The idea is to train the model on one set of data and test it on a naive set of data. Random forests are nice because you have a built-in way of estimating the model error. Since only ~2/3 of the data is used everytime we bootstrap our samples for construction of the kth tree, we can use the remaining ~1/3 of the data (called the out of bag samples) to test model error

#Our out of bag error is 6.25% .

# What variables are stored in the output?
names(physeq.classify)


imp <- importance(physeq.classify)
imp <- data.frame(predictors = rownames(imp), imp)

# Order the predictor levels by importance
imp.sort <- arrange(imp, desc(MeanDecreaseGini))
imp.sort$predictors <- factor(imp.sort$predictors, levels = imp.sort$predictors)

#We need some editing to remove leading "X" in front of ASV names that should start with a numeral.
imp.sort$predictors <- str_remove(imp.sort$predictors, "[X]")

# Select the top 20 predictors
imp.20 <- imp.sort[1:20, ]

imp.20$predictors <-  factor(imp.20$predictors, levels = imp.20$predictors)

# ggplot
ggplot(imp.20, aes(x = predictors, y = MeanDecreaseGini)) +
  geom_bar(stat = "identity", fill = "indianred") +
  coord_flip() +
  ggtitle(paste("Most important ASVs between", rf.samples[1], "and ", rf.samples[2]))


# What are those OTUs?
otunames <- imp.20$predictors
r <- rownames(tax_table(physeq)) %in% otunames
rf.imp.asv <- as.data.frame(tax_table(physeq)[r, ])
imp.20_tax <- merge(imp.20, rf.imp.asv, by.x = "predictors", by.y = 0)

# New ggplot
ggplot(imp.20_tax, aes(x = predictors, y = MeanDecreaseGini)) +
  geom_bar(stat = "identity", aes(fill = Family)) +
  scale_fill_manual(values = my_colors) +
  coord_flip() +
  ggtitle(paste("Most important ASVs between", rf.samples[1], "and", rf.samples[2]))
ggsave(paste0("RandomForest_", rf.samples[1], "_", rf.samples[2], "_names.png"), height = 4, width = 7)
write.table(imp.20_tax, "rf_top20_taxa_meth-kan+meth.tsv", sep="\t", row.names=FALSE, quote = FALSE)
```


## To compare meth-kan
```{r}
#install.packages("randomForest")
library(randomForest)
#Check how many OTUs you have. If you have more than 1000, you may want to filter out rare OTUs, as shown below.

ntaxa(physeq)

# Set prunescale 
prunescale = 0.0001
seq_depth = sample_sums(physeq)[1]

# Prune out rare OTUs by mean relative abundance set by prunescale
tax.mean <- taxa_sums(physeq)/nsamples(physeq)

#Select the samples we want to compare
rf.samples = c("meth", "kan")
physeq.prune <- prune_taxa(tax.mean > prunescale*seq_depth, physeq)
physeq.prune2 <- prune_samples(sample_data(physeq.prune)$treatment == rf.samples[1] | sample_data(physeq.prune)$treatment == rf.samples[2], physeq.prune)

physeq.prune2

# Make a dataframe of training data with OTUs as column and samples as rows
predictors <- t(otu_table(physeq.prune2))
dim(predictors)

# Make one column for our outcome/response variable 
response <- as.factor(sample_data(physeq.prune2)$treatment)

# Combine them into 1 data frame
rf.data <- data.frame(response, predictors)

#Results
set.seed(2)

physeq.classify <- randomForest(response~., data = rf.data, ntree = 100)
print(physeq.classify)
#In most statistical learning algorithms, the data needs to be split up into “training” and “test” data. The idea is to train the model on one set of data and test it on a naive set of data. Random forests are nice because you have a built-in way of estimating the model error. Since only ~2/3 of the data is used everytime we bootstrap our samples for construction of the kth tree, we can use the remaining ~1/3 of the data (called the out of bag samples) to test model error

#Our out of bag error is 6.25% .

# What variables are stored in the output?
names(physeq.classify)


imp <- importance(physeq.classify)
imp <- data.frame(predictors = rownames(imp), imp)

# Order the predictor levels by importance
imp.sort <- arrange(imp, desc(MeanDecreaseGini))
imp.sort$predictors <- factor(imp.sort$predictors, levels = imp.sort$predictors)

#We need some editing to remove leading "X" in front of ASV names that should start with a numeral.
imp.sort$predictors <- str_remove(imp.sort$predictors, "[X]")

# Select the top 20 predictors
imp.20 <- imp.sort[1:20, ]

imp.20$predictors <-  factor(imp.20$predictors, levels = imp.20$predictors)

# ggplot
ggplot(imp.20, aes(x = predictors, y = MeanDecreaseGini)) +
  geom_bar(stat = "identity", fill = "indianred") +
  coord_flip() +
  ggtitle(paste("Most important ASVs between", rf.samples[1], "and ", rf.samples[2]))


# What are those OTUs?
otunames <- imp.20$predictors
r <- rownames(tax_table(physeq)) %in% otunames
rf.imp.asv <- as.data.frame(tax_table(physeq)[r, ])
imp.20_tax <- merge(imp.20, rf.imp.asv, by.x = "predictors", by.y = 0)

# New ggplot
ggplot(imp.20_tax, aes(x = predictors, y = MeanDecreaseGini)) +
  geom_bar(stat = "identity", aes(fill = Family)) +
  scale_fill_manual(values = my_colors) +
  coord_flip() +
  ggtitle(paste("Most important ASVs between", rf.samples[1], "and", rf.samples[2]))
ggsave(paste0("RandomForest_", rf.samples[1], "_", rf.samples[2], "_names.png"), height = 4, width = 7)
write.table(imp.20_tax, "rf_top20_taxa-meth-kan.tsv", sep="\t", row.names=FALSE, quote = FALSE)
```


##To compare biocontrol-kan+meth

```{r}
#install.packages("randomForest")
library(randomForest)
#Check how many OTUs you have. If you have more than 1000, you may want to filter out rare OTUs, as shown below.

ntaxa(physeq)

# Set prunescale 
prunescale = 0.0001
seq_depth = sample_sums(physeq)[1]

# Prune out rare OTUs by mean relative abundance set by prunescale
tax.mean <- taxa_sums(physeq)/nsamples(physeq)

#Select the samples we want to compare
rf.samples = c("biocontrol", "kan+meth")
physeq.prune <- prune_taxa(tax.mean > prunescale*seq_depth, physeq)
physeq.prune2 <- prune_samples(sample_data(physeq.prune)$treatment == rf.samples[1] | sample_data(physeq.prune)$treatment == rf.samples[2], physeq.prune)

physeq.prune2

# Make a dataframe of training data with OTUs as column and samples as rows
predictors <- t(otu_table(physeq.prune2))
dim(predictors)

# Make one column for our outcome/response variable 
response <- as.factor(sample_data(physeq.prune2)$treatment)

# Combine them into 1 data frame
rf.data <- data.frame(response, predictors)

#Results
set.seed(2)

physeq.classify <- randomForest(response~., data = rf.data, ntree = 100)
print(physeq.classify)
#In most statistical learning algorithms, the data needs to be split up into “training” and “test” data. The idea is to train the model on one set of data and test it on a naive set of data. Random forests are nice because you have a built-in way of estimating the model error. Since only ~2/3 of the data is used everytime we bootstrap our samples for construction of the kth tree, we can use the remaining ~1/3 of the data (called the out of bag samples) to test model error

#Our out of bag error is 6.25% .

# What variables are stored in the output?
names(physeq.classify)


imp <- importance(physeq.classify)
imp <- data.frame(predictors = rownames(imp), imp)

# Order the predictor levels by importance
imp.sort <- arrange(imp, desc(MeanDecreaseGini))
imp.sort$predictors <- factor(imp.sort$predictors, levels = imp.sort$predictors)

#We need some editing to remove leading "X" in front of ASV names that should start with a numeral.
imp.sort$predictors <- str_remove(imp.sort$predictors, "[X]")

# Select the top 20 predictors
imp.20 <- imp.sort[1:20, ]

imp.20$predictors <-  factor(imp.20$predictors, levels = imp.20$predictors)

# ggplot
ggplot(imp.20, aes(x = predictors, y = MeanDecreaseGini)) +
  geom_bar(stat = "identity", fill = "indianred") +
  coord_flip() +
  ggtitle(paste("Most important ASVs between", rf.samples[1], "and ", rf.samples[2]))


# What are those OTUs?
otunames <- imp.20$predictors
r <- rownames(tax_table(physeq)) %in% otunames
rf.imp.asv <- as.data.frame(tax_table(physeq)[r, ])
imp.20_tax <- merge(imp.20, rf.imp.asv, by.x = "predictors", by.y = 0)

# New ggplot
ggplot(imp.20_tax, aes(x = predictors, y = MeanDecreaseGini)) +
  geom_bar(stat = "identity", aes(fill = Family)) +
  scale_fill_manual(values = my_colors) +
  coord_flip() +
  ggtitle(paste("Most important ASVs between", rf.samples[1], "and", rf.samples[2]))
ggsave(paste0("RandomForest_", rf.samples[1], "_", rf.samples[2], "_names.png"), height = 4, width = 7)
write.table(imp.20_tax, "rf_top20_taxa-biocontrol-kan+meth.tsv", sep="\t", row.names=FALSE, quote = FALSE)
```

#To compare biocontrol-kan
```{r}
#install.packages("randomForest")
library(randomForest)
#Check how many OTUs you have. If you have more than 1000, you may want to filter out rare OTUs, as shown below.

ntaxa(physeq)

# Set prunescale 
prunescale = 0.0001
seq_depth = sample_sums(physeq)[1]

# Prune out rare OTUs by mean relative abundance set by prunescale
tax.mean <- taxa_sums(physeq)/nsamples(physeq)

#Select the samples we want to compare
rf.samples = c("biocontrol", "kan")
physeq.prune <- prune_taxa(tax.mean > prunescale*seq_depth, physeq)
physeq.prune2 <- prune_samples(sample_data(physeq.prune)$treatment == rf.samples[1] | sample_data(physeq.prune)$treatment == rf.samples[2], physeq.prune)

physeq.prune2

# Make a dataframe of training data with OTUs as column and samples as rows
predictors <- t(otu_table(physeq.prune2))
dim(predictors)

# Make one column for our outcome/response variable 
response <- as.factor(sample_data(physeq.prune2)$treatment)

# Combine them into 1 data frame
rf.data <- data.frame(response, predictors)

#Results
set.seed(2)

physeq.classify <- randomForest(response~., data = rf.data, ntree = 100)
print(physeq.classify)
#In most statistical learning algorithms, the data needs to be split up into “training” and “test” data. The idea is to train the model on one set of data and test it on a naive set of data. Random forests are nice because you have a built-in way of estimating the model error. Since only ~2/3 of the data is used everytime we bootstrap our samples for construction of the kth tree, we can use the remaining ~1/3 of the data (called the out of bag samples) to test model error

#Our out of bag error is 6.25% .

# What variables are stored in the output?
names(physeq.classify)


imp <- importance(physeq.classify)
imp <- data.frame(predictors = rownames(imp), imp)

# Order the predictor levels by importance
imp.sort <- arrange(imp, desc(MeanDecreaseGini))
imp.sort$predictors <- factor(imp.sort$predictors, levels = imp.sort$predictors)

#We need some editing to remove leading "X" in front of ASV names that should start with a numeral.
imp.sort$predictors <- str_remove(imp.sort$predictors, "[X]")

# Select the top 20 predictors
imp.20 <- imp.sort[1:20, ]

imp.20$predictors <-  factor(imp.20$predictors, levels = imp.20$predictors)

# ggplot
ggplot(imp.20, aes(x = predictors, y = MeanDecreaseGini)) +
  geom_bar(stat = "identity", fill = "indianred") +
  coord_flip() +
  ggtitle(paste("Most important ASVs between", rf.samples[1], "and ", rf.samples[2]))


# What are those OTUs?
otunames <- imp.20$predictors
r <- rownames(tax_table(physeq)) %in% otunames
rf.imp.asv <- as.data.frame(tax_table(physeq)[r, ])
imp.20_tax <- merge(imp.20, rf.imp.asv, by.x = "predictors", by.y = 0)

# New ggplot
ggplot(imp.20_tax, aes(x = predictors, y = MeanDecreaseGini)) +
  geom_bar(stat = "identity", aes(fill = Family)) +
  scale_fill_manual(values = my_colors) +
  coord_flip() +
  ggtitle(paste("Most important ASVs between", rf.samples[1], "and", rf.samples[2]))
ggsave(paste0("RandomForest_", rf.samples[1], "_", rf.samples[2], "_names.png"), height = 4, width = 7)
write.table(imp.20_tax, "rf_top20_taxa-biocontrol-kan.tsv", sep="\t", row.names=FALSE, quote = FALSE)
```

To compare Kan+meth-kan

```{r}
#install.packages("randomForest")
library(randomForest)
#Check how many OTUs you have. If you have more than 1000, you may want to filter out rare OTUs, as shown below.

ntaxa(physeq)

# Set prunescale 
prunescale = 0.0001
seq_depth = sample_sums(physeq)[1]

# Prune out rare OTUs by mean relative abundance set by prunescale
tax.mean <- taxa_sums(physeq)/nsamples(physeq)

#Select the samples we want to compare
rf.samples = c("kan", "kan+meth")
physeq.prune <- prune_taxa(tax.mean > prunescale*seq_depth, physeq)
physeq.prune2 <- prune_samples(sample_data(physeq.prune)$treatment == rf.samples[1] | sample_data(physeq.prune)$treatment == rf.samples[2], physeq.prune)

physeq.prune2

# Make a dataframe of training data with OTUs as column and samples as rows
predictors <- t(otu_table(physeq.prune2))
dim(predictors)

# Make one column for our outcome/response variable 
response <- as.factor(sample_data(physeq.prune2)$treatment)

# Combine them into 1 data frame
rf.data <- data.frame(response, predictors)

#Results
set.seed(2)

physeq.classify <- randomForest(response~., data = rf.data, ntree = 100)
print(physeq.classify)
#In most statistical learning algorithms, the data needs to be split up into “training” and “test” data. The idea is to train the model on one set of data and test it on a naive set of data. Random forests are nice because you have a built-in way of estimating the model error. Since only ~2/3 of the data is used everytime we bootstrap our samples for construction of the kth tree, we can use the remaining ~1/3 of the data (called the out of bag samples) to test model error

#Our out of bag error is 6.25% .

# What variables are stored in the output?
names(physeq.classify)


imp <- importance(physeq.classify)
imp <- data.frame(predictors = rownames(imp), imp)

# Order the predictor levels by importance
imp.sort <- arrange(imp, desc(MeanDecreaseGini))
imp.sort$predictors <- factor(imp.sort$predictors, levels = imp.sort$predictors)

#We need some editing to remove leading "X" in front of ASV names that should start with a numeral.
imp.sort$predictors <- str_remove(imp.sort$predictors, "[X]")

# Select the top 20 predictors
imp.20 <- imp.sort[1:20, ]

imp.20$predictors <-  factor(imp.20$predictors, levels = imp.20$predictors)

# ggplot
ggplot(imp.20, aes(x = predictors, y = MeanDecreaseGini)) +
  geom_bar(stat = "identity", fill = "indianred") +
  coord_flip() +
  ggtitle(paste("Most important ASVs between", rf.samples[1], "and ", rf.samples[2]))


# What are those OTUs?
otunames <- imp.20$predictors
r <- rownames(tax_table(physeq)) %in% otunames
rf.imp.asv <- as.data.frame(tax_table(physeq)[r, ])
imp.20_tax <- merge(imp.20, rf.imp.asv, by.x = "predictors", by.y = 0)

# New ggplot
ggplot(imp.20_tax, aes(x = predictors, y = MeanDecreaseGini)) +
  geom_bar(stat = "identity", aes(fill = Family)) +
  scale_fill_manual(values = my_colors) +
  coord_flip() +
  ggtitle(paste("Most important ASVs between", rf.samples[1], "and", rf.samples[2]))
ggsave(paste0("RandomForest_", rf.samples[1], "_", rf.samples[2], "_names.png"), height = 4, width = 7)
write.table(imp.20_tax, "rf_top20_taxa-kan-kan+meth.tsv", sep="\t", row.names=FALSE, quote = FALSE)
```


###Differential Abundance with DESeq2

Adapted from https://joey711.github.io/phyloseq-extensions/DESeq2.html


if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("DESeq2")

```{r}
library("DESeq2")
```

To use DESeq, we need no zeros in our OTU table. So we will edit the table by multiplying by 2 and + 1

```{r}
OTU.clean2 <- OTU.clean * 2 + 1
```

Now make the phyloseq object:

```{r}
OTU.physeq = otu_table(as.matrix(OTU.clean2), taxa_are_rows=FALSE)
tax.physeq = tax_table(as.matrix(tax.clean))
meta.physeq = sample_data(meta)
sample_names(meta.physeq)
sample_names(OTU.physeq)
```

We then merge these into an object of class phyloseq.


```{r}
physeq_deseq = phyloseq(OTU.physeq, tax.physeq, meta.physeq)
```



```{r}
diagdds = phyloseq_to_deseq2(physeq_deseq, ~ treatment)
diagdds = DESeq(diagdds, test="Wald", fitType="parametric")
#the test type of "Wald" tests for significance of coefficients in a Negative Binomial GLM. This is generally a pretty good assumption for sequencing experiments. This was designed with RNA-seq in mind, but also pretty good for 16S sequencing.
```

###Investigate test results table


###For meth and biocontrol comparisons

```{r}
my_contrast = c("treatment", "meth", "biocontrol") ##first is numerator in the fold change and second is denominator, the negatives are more abundant in biocontrol.
res = results(diagdds, contrast = my_contrast, cooksCutoff = FALSE)

alpha = 0.01
sigtab = res[which(res$padj < alpha), ]
sigtab = cbind(as(sigtab, "data.frame"), as(tax_table(physeq_deseq)[rownames(sigtab), ], "matrix"))
#head(sigtab)
```

Volcano Plot
```{r}
#reset par
par(mfrow=c(1,1))
# Make a basic volcano plot
with(res, plot(log2FoldChange, -log10(pvalue), pch=20, main="Volcano plot", xlim=c(-15,15)))

# Add colored points: blue if padj<0.01, red if log2FC>1 and padj<0.05)
with(subset(res, padj<.01 ), points(log2FoldChange, -log10(pvalue), pch=20, col="blue"))
with(subset(res, padj<.01 & abs(log2FoldChange)>2), points(log2FoldChange, -log10(pvalue), pch=20, col="red"))
```

Let's look at the OTUs that were significantly different between the two treatment groups. The following makes a nice ggplot2 summary of the results.

```{r}
theme_set(theme_bw())
scale_fill_discrete <- function(palname = "Set1", ...) {
    scale_fill_brewer(palette = palname, ...)
}
# Phylum order
x = tapply(sigtab$log2FoldChange, sigtab$Phylum, function(x) max(x))
x = sort(x, TRUE)
sigtab$Phylum = factor(as.character(sigtab$Phylum), levels=names(x))
# Genus order
x = tapply(sigtab$log2FoldChange, sigtab$Genus, function(x) max(x))
x = sort(x, TRUE)
sigtab$Genus = factor(as.character(sigtab$Genus), levels=names(x))

DESeq_fig = ggplot(sigtab, aes(x=Genus, y = log2FoldChange, color=Phylum)) + geom_point(size=3) + 
  theme(axis.text.x = element_text(angle = -90, hjust = 0, vjust=0.5)) + 
  ylab("log2(meth/biocontrol)")

ggsave(paste0("DESeq2-", my_contrast[2], "-", my_contrast[3], ".png"), DESeq_fig, height = 4, width = 4)
```

###For meth and kan+meth comparisons

```{r}
my_contrast = c("treatment", "meth", "kan+meth")
res = results(diagdds, contrast = my_contrast, cooksCutoff = FALSE)

alpha = 0.01
sigtab = res[which(res$padj < alpha), ]
sigtab = cbind(as(sigtab, "data.frame"), as(tax_table(physeq_deseq)[rownames(sigtab), ], "matrix"))
#head(sigtab)
```

Volcano Plot
```{r}
#reset par
par(mfrow=c(1,1))
# Make a basic volcano plot
with(res, plot(log2FoldChange, -log10(pvalue), pch=20, main="Volcano plot", xlim=c(-15,15)))

# Add colored points: blue if padj<0.01, red if log2FC>1 and padj<0.05)
with(subset(res, padj<.01 ), points(log2FoldChange, -log10(pvalue), pch=20, col="blue"))
with(subset(res, padj<.01 & abs(log2FoldChange)>2), points(log2FoldChange, -log10(pvalue), pch=20, col="red"))
```



```{r}
theme_set(theme_bw())
scale_fill_discrete <- function(palname = "Set1", ...) {
    scale_fill_brewer(palette = palname, ...)
}
# Phylum order
x = tapply(sigtab$log2FoldChange, sigtab$Phylum, function(x) max(x))
x = sort(x, TRUE)
sigtab$Phylum = factor(as.character(sigtab$Phylum), levels=names(x))
# Genus order
x = tapply(sigtab$log2FoldChange, sigtab$Genus, function(x) max(x))
x = sort(x, TRUE)
sigtab$Genus = factor(as.character(sigtab$Genus), levels=names(x))

DESeq_fig = ggplot(sigtab, aes(x=Genus, y = log2FoldChange, color=Phylum)) + geom_point(size=3) + 
  theme(axis.text.x = element_text(angle = -90, hjust = 0, vjust=0.5)) + 
  ylab("log2(meth/kan+meth)")

ggsave(paste0("DESeq2-", my_contrast[2], "-", my_contrast[3], ".png"), DESeq_fig, height = 4, width = 4)
```


###For meth and kan comparisons

```{r}
my_contrast = c("treatment", "meth", "kan")
res = results(diagdds, contrast = my_contrast, cooksCutoff = FALSE)

alpha = 0.01
sigtab = res[which(res$padj < alpha), ]
sigtab = cbind(as(sigtab, "data.frame"), as(tax_table(physeq_deseq)[rownames(sigtab), ], "matrix"))
#head(sigtab)
```

Volcano Plot
```{r}
#reset par
par(mfrow=c(1,1))
# Make a basic volcano plot
with(res, plot(log2FoldChange, -log10(pvalue), pch=20, main="Volcano plot", xlim=c(-15,15)))

# Add colored points: blue if padj<0.01, red if log2FC>1 and padj<0.05)
with(subset(res, padj<.01 ), points(log2FoldChange, -log10(pvalue), pch=20, col="blue"))
with(subset(res, padj<.01 & abs(log2FoldChange)>2), points(log2FoldChange, -log10(pvalue), pch=20, col="red"))
```


Let's look at the OTUs that were significantly different between the two treatment groups. The following makes a nice ggplot2 summary of the results.

```{r}
theme_set(theme_bw())
scale_fill_discrete <- function(palname = "Set1", ...) {
    scale_fill_brewer(palette = palname, ...)
}
# Phylum order
x = tapply(sigtab$log2FoldChange, sigtab$Phylum, function(x) max(x))
x = sort(x, TRUE)
sigtab$Phylum = factor(as.character(sigtab$Phylum), levels=names(x))
# Genus order
x = tapply(sigtab$log2FoldChange, sigtab$Genus, function(x) max(x))
x = sort(x, TRUE)
sigtab$Genus = factor(as.character(sigtab$Genus), levels=names(x))

DESeq_fig = ggplot(sigtab, aes(x=Genus, y = log2FoldChange, color=Phylum)) + geom_point(size=3) + 
  theme(axis.text.x = element_text(angle = -90, hjust = 0, vjust=0.5)) + 
  ylab("log2(meth/kan)")

ggsave(paste0("DESeq2-", my_contrast[2], "-", my_contrast[3], ".png"), DESeq_fig, height = 4, width = 4)
```


###For biocontrol and kan+meth comparisons

```{r}
my_contrast = c("treatment", "biocontrol", "kan+meth")
res = results(diagdds, contrast = my_contrast, cooksCutoff = FALSE)

alpha = 0.01
sigtab = res[which(res$padj < alpha), ]
sigtab = cbind(as(sigtab, "data.frame"), as(tax_table(physeq_deseq)[rownames(sigtab), ], "matrix"))
#head(sigtab)
```

Volcano Plot
```{r}
#reset par
par(mfrow=c(1,1))
# Make a basic volcano plot
with(res, plot(log2FoldChange, -log10(pvalue), pch=20, main="Volcano plot", xlim=c(-15,15)))

# Add colored points: blue if padj<0.01, red if log2FC>1 and padj<0.05)
with(subset(res, padj<.01 ), points(log2FoldChange, -log10(pvalue), pch=20, col="blue"))
with(subset(res, padj<.01 & abs(log2FoldChange)>2), points(log2FoldChange, -log10(pvalue), pch=20, col="red"))
```

Let's look at the OTUs that were significantly different between the two treatment groups. The following makes a nice ggplot2 summary of the results.

```{r}
theme_set(theme_bw())
scale_fill_discrete <- function(palname = "Set1", ...) {
    scale_fill_brewer(palette = palname, ...)
}
# Phylum order
x = tapply(sigtab$log2FoldChange, sigtab$Phylum, function(x) max(x))
x = sort(x, TRUE)
sigtab$Phylum = factor(as.character(sigtab$Phylum), levels=names(x))
# Genus order
x = tapply(sigtab$log2FoldChange, sigtab$Genus, function(x) max(x))
x = sort(x, TRUE)
sigtab$Genus = factor(as.character(sigtab$Genus), levels=names(x))

DESeq_fig = ggplot(sigtab, aes(x=Genus, y = log2FoldChange, color=Phylum)) + geom_point(size=3) + 
  theme(axis.text.x = element_text(angle = -90, hjust = 0, vjust=0.5)) + 
  ylab("log2(biocontrol/kan+meth)")


ggsave(paste0("DESeq2-", my_contrast[2], "-", my_contrast[3], ".png"), DESeq_fig, height = 4, width = 4)
```


###For biocontrol and kan comparisons

```{r}
my_contrast = c("treatment", "biocontrol", "kan")
res = results(diagdds, contrast = my_contrast, cooksCutoff = FALSE)

alpha = 0.01
sigtab = res[which(res$padj < alpha), ]
sigtab = cbind(as(sigtab, "data.frame"), as(tax_table(physeq_deseq)[rownames(sigtab), ], "matrix"))
#head(sigtab)
```

Volcano Plot
```{r}
#reset par
par(mfrow=c(1,1))
# Make a basic volcano plot
with(res, plot(log2FoldChange, -log10(pvalue), pch=20, main="Volcano plot", xlim=c(-15,15)))

# Add colored points: blue if padj<0.01, red if log2FC>1 and padj<0.05)
with(subset(res, padj<.01 ), points(log2FoldChange, -log10(pvalue), pch=20, col="blue"))
with(subset(res, padj<.01 & abs(log2FoldChange)>2), points(log2FoldChange, -log10(pvalue), pch=20, col="red"))
```

Let's look at the OTUs that were significantly different between the two treatment groups. The following makes a nice ggplot2 summary of the results.

```{r}
theme_set(theme_bw())
scale_fill_discrete <- function(palname = "Set1", ...) {
    scale_fill_brewer(palette = palname, ...)
}
# Phylum order
x = tapply(sigtab$log2FoldChange, sigtab$Phylum, function(x) max(x))
x = sort(x, TRUE)
sigtab$Phylum = factor(as.character(sigtab$Phylum), levels=names(x))
# Genus order
x = tapply(sigtab$log2FoldChange, sigtab$Genus, function(x) max(x))
x = sort(x, TRUE)
sigtab$Genus = factor(as.character(sigtab$Genus), levels=names(x))

DESeq_fig = ggplot(sigtab, aes(x=Genus, y = log2FoldChange, color=Phylum)) + geom_point(size=3) + 
  theme(axis.text.x = element_text(angle = -90, hjust = 0, vjust=0.5)) + 
  ylab("log2(biocontrol/kan)")

ggsave(paste0("DESeq2-", my_contrast[2], "-", my_contrast[3], ".png"), DESeq_fig, height = 4, width = 4)
```


###For kan+meth and kan comparisons

```{r}
my_contrast = c("treatment", "kan+meth", "kan")
res = results(diagdds, contrast = my_contrast, cooksCutoff = FALSE)

alpha = 0.01
sigtab = res[which(res$padj < alpha), ]
sigtab = cbind(as(sigtab, "data.frame"), as(tax_table(physeq_deseq)[rownames(sigtab), ], "matrix"))
#head(sigtab)
```

Volcano Plot
```{r}
#reset par
par(mfrow=c(1,1))
# Make a basic volcano plot
with(res, plot(log2FoldChange, -log10(pvalue), pch=20, main="Volcano plot", xlim=c(-15,15)))

# Add colored points: blue if padj<0.01, red if log2FC>1 and padj<0.05)
with(subset(res, padj<.01 ), points(log2FoldChange, -log10(pvalue), pch=20, col="blue"))
with(subset(res, padj<.01 & abs(log2FoldChange)>2), points(log2FoldChange, -log10(pvalue), pch=20, col="red"))
```

Let's look at the OTUs that were significantly different between the two treatment groups. The following makes a nice ggplot2 summary of the results.

```{r}
theme_set(theme_bw())
scale_fill_discrete <- function(palname = "Set1", ...) {
    scale_fill_brewer(palette = palname, ...)
}
# Phylum order
x = tapply(sigtab$log2FoldChange, sigtab$Phylum, function(x) max(x))
x = sort(x, TRUE)
sigtab$Phylum = factor(as.character(sigtab$Phylum), levels=names(x))
# Genus order
x = tapply(sigtab$log2FoldChange, sigtab$Genus, function(x) max(x))
x = sort(x, TRUE)
sigtab$Genus = factor(as.character(sigtab$Genus), levels=names(x))

DESeq_fig = ggplot(sigtab, aes(x=Genus, y = log2FoldChange, color=Phylum)) + geom_point(size=3) + 
  theme(axis.text.x = element_text(angle = -90, hjust = 0, vjust=0.5)) + 
  ylab("log2(kan+meth/kan)")

ggsave(paste0("DESeq2-", my_contrast[2], "-", my_contrast[3], ".png"), DESeq_fig, height = 4, width = 4)
```





##Heat maps
There are some good options in both `phyloseq` and `gplots` to make heatmaps. We will go through `phyloseq` but know that the same things could be done in `gplots` with code specific to that package.

##Heatmap

```{r}
library("phyloseq"); packageVersion("phyloseq")
library("ggplot2"); packageVersion("ggplot2")
theme_set(theme_bw())
```


```{r}

physeq.prune2 <- prune_samples(sample_data(physeq)$treatment == "kan" | sample_data(physeq)$treatment == "kan+meth"| sample_data(physeq)$treatment == "meth" |sample_data(physeq)$treatment == "biocontrol", physeq)

plot_heatmap(physeq.prune2, taxa.label="Phylum")

```


And grouped by our age groups
```{r}
##worked
plot_heatmap(physeq.prune2, sample.label="treatment", sample.order="treatment")
```

We can label the OTU taxa
```{r}
##Worked#!
plot_heatmap(physeq.prune2, sample.label="treatment", sample.order="treatment", taxa.label="Genus")
```

And group OTUs within the same Phyla
```{r}
plot_heatmap(physeq.prune2, sample.label="treatment", sample.order="treatment", taxa.label="Genus", taxa.order="Phylum")
```

We can also change the colors (white -> purple), including the 0s/NAs (grey).
```{r}
plot_heatmap(physeq.prune2, sample.label="treatment", sample.order="treatment", taxa.label="Genus", taxa.order="Phylum", low="white", high="blue", na.value="grey")
```



```{r}
plot_heatmap(physeq.prune2, "NMDS", "bray", title="Bray-Curtis")
```


```{r}
##Worked#! (OTUs on phylum level)
plot_heatmap(physeq.prune2, sample.label="treatment", sample.order="treatment", taxa.label="Phylum")
plot_heatmap(physeq.prune2, sample.label="treatment", sample.order="treatment", taxa.label="Phylum", low="white", high="blue", na.value="grey")
```

```{r}
##Worked#! (OTUs on family level)
plot_heatmap(physeq.prune2, sample.label="treatment", sample.order="treatment", taxa.label="Family")
plot_heatmap(physeq.prune2, sample.label="treatment", sample.order="treatment", taxa.label="Family", low="white", high="blue", na.value="grey")
```


##No need to do top 20 OTUs
###OTUs
We're going to just look at the 20 most abundant OTUs to make it more readable.
```{r Heat_maps}
##No need to do top 20 OTUs

#Sort the OTUs by abundance and pick the top 20
top20OTU.names = names(sort(taxa_sums(physeq.prune2), TRUE)[1:20])
#Cut down the physeq data to only the top 10 Phyla
top20OTU = prune_taxa(top20OTU.names, physeq.prune2)
```

We now see that we only have 20 taxa
```{r}
top20OTU
```

First, you can make a heatmap of OTU abundance across all samples
```{r}
plot_heatmap(top20OTU)
```

And grouped by our age groups
```{r}
plot_heatmap(top20OTU, sample.label="treatment", sample.order="treatment")
```

We can label the OTU taxa
```{r}
plot_heatmap(top20OTU, sample.label="treatment", sample.order="treatment", taxa.label="Genus")
```

And group OTUs within the same Phyla
```{r}
plot_heatmap(top20OTU, sample.label="treatment", sample.order="treatment", taxa.label="Genus", taxa.order="Phylum")
```

We can also change the colors (white -> purple), including the 0s/NAs (grey).
```{r}
plot_heatmap(top20OTU, sample.label="treatment", sample.order="treatment", taxa.label="Genus", taxa.order="Phylum", low="white", high="purple", na.value="grey")
```


```{r}
plot_heatmap(top20OTU, "NMDS", "bray", title="Bray-Curtis")
```


